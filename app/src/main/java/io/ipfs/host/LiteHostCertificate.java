package io.ipfs.host;

import androidx.annotation.NonNull;

import com.google.common.primitives.Bytes;
import com.google.common.primitives.Ints;
import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;

import org.bouncycastle.asn1.ASN1Encodable;
import org.bouncycastle.asn1.ASN1Object;
import org.bouncycastle.asn1.ASN1ObjectIdentifier;
import org.bouncycastle.asn1.ASN1OctetString;
import org.bouncycastle.asn1.ASN1Primitive;
import org.bouncycastle.asn1.DEROctetString;
import org.bouncycastle.asn1.DERSequence;
import org.bouncycastle.asn1.DLSequence;
import org.bouncycastle.asn1.x500.X500Name;
import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;
import org.bouncycastle.cert.X509CertificateHolder;
import org.bouncycastle.cert.X509v3CertificateBuilder;
import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter;
import org.bouncycastle.cert.jcajce.JcaX509v3CertificateBuilder;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.operator.ContentSigner;
import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.math.BigInteger;
import java.security.KeyPair;
import java.security.PrivateKey;
import java.security.Provider;
import java.security.SecureRandom;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.util.Date;
import java.util.Objects;
import java.util.Random;

import crypto.pb.Crypto;
import io.ipfs.crypto.Ecdsa;
import io.ipfs.crypto.Ed25519;
import io.ipfs.crypto.PrivKey;
import io.ipfs.crypto.PubKey;
import io.ipfs.crypto.Rsa;
import io.ipfs.crypto.Secp256k1;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.handler.codec.base64.Base64;
import io.netty.util.CharsetUtil;
import io.netty.util.internal.PlatformDependent;
import io.netty.util.internal.SystemPropertyUtil;
import io.netty.util.internal.logging.InternalLogger;
import io.netty.util.internal.logging.InternalLoggerFactory;

/**
 * Generates a temporary self-signed certificate for testing purposes.
 * <p>
 * <strong>NOTE:</strong>
 * Never use the certificate and private key generated by this class in production.
 * It is purely for testing purposes, and thus it is very insecure.
 * It even uses an insecure pseudo-random generator for faster generation internally.
 * </p><p>
 * An X.509 certificate file and a EC/RSA private key file are generated in a system's temporary directory using
 * {@link java.io.File#createTempFile(String, String)}, and they are deleted when the JVM exits using
 * {@link java.io.File#deleteOnExit()}.
 * </p><p>
 * At first, this method tries to use OpenJDK's X.509 implementation (the {@code sun.security.x509} package).
 * If it fails, it tries to use <a href="https://www.bouncycastle.org/">Bouncy Castle</a> as a fallback.
 * </p>
 */
public final class LiteHostCertificate {
    public static final String certificatePrefix = "libp2p-tls-handshake:";
    private static final InternalLogger logger = InternalLoggerFactory.getInstance(
            io.netty.handler.ssl.util.SelfSignedCertificate.class);
    /**
     * Current time minus 1 year, just in case software clock goes back due to time synchronization
     */
    private static final Date DEFAULT_NOT_BEFORE = new Date(SystemPropertyUtil.getLong(
            "io.netty.selfSignedCertificate.defaultNotBefore", System.currentTimeMillis() - 86400000L * 365));
    /**
     * The maximum possible value in X.509 specification: 9999-12-31 23:59:59
     */
    private static final Date DEFAULT_NOT_AFTER = new Date(SystemPropertyUtil.getLong(
            "io.netty.selfSignedCertificate.defaultNotAfter", 253402300799000L));
    private static final int[] extensionPrefix = new int[]{1, 3, 6, 1, 4, 1, 53594};
    public static final int[] extensionID = getPrefixedExtensionID(new int[]{1, 1});
    private static final Provider PROVIDER = new BouncyCastleProvider();

    /**
     * FIPS 140-2 encryption requires the RSA key length to be 2048 bits or greater.
     * Let's use that as a sane default but allow the default to be set dynamically
     * for those that need more stringent security requirements.
     */
    private final File certificate;
    private final File privateKey;
    private final X509Certificate cert;
    private final PrivateKey key;


    /**
     * Creates a new instance.
     * <p> Algorithm: RSA </p>
     */
    public LiteHostCertificate(PrivKey privKey, KeyPair keypair) throws Exception {
        this(privKey, keypair, DEFAULT_NOT_BEFORE, DEFAULT_NOT_AFTER);
    }


    /**
     * Creates a new instance.
     * <p> Algorithm: RSA </p>
     *
     * @param notBefore Certificate is not valid before this time
     * @param notAfter  Certificate is not valid after this time
     */
    public LiteHostCertificate(PrivKey privKey, KeyPair keypair, Date notBefore, Date notAfter)
            throws Exception {
        this(privKey, keypair, "localhost", notBefore, notAfter);
    }

    /**
     * Creates a new instance.
     * <p> Algorithm: RSA </p>
     *
     * @param fqdn      a fully qualified domain name
     * @param notBefore Certificate is not valid before this time
     * @param notAfter  Certificate is not valid after this time
     */
    public LiteHostCertificate(PrivKey privKey, KeyPair keypair, String fqdn, Date notBefore, Date notAfter)
            throws Exception {
        // Bypass entropy collection by using insecure random generator.
        // We just want to generate it without any delay because it's for testing purposes only.
        this(privKey, keypair, fqdn, ThreadLocalInsecureRandom.current(), notBefore, notAfter);
    }

    /**
     * Creates a new instance.
     *
     * @param fqdn      a fully qualified domain name
     * @param random    the {@link SecureRandom} to use
     * @param notBefore Certificate is not valid before this time
     * @param notAfter  Certificate is not valid after this time
     */
    public LiteHostCertificate(PrivKey privKey, KeyPair keypair, String fqdn,
                               SecureRandom random, Date notBefore, Date notAfter)
            throws Exception {


        String algorithm = keypair.getPublic().getAlgorithm();
        String[] paths = generate(privKey, fqdn, keypair, random, notBefore, notAfter, algorithm);

        certificate = new File(paths[0]);
        privateKey = new File(paths[1]);
        key = keypair.getPrivate();
        FileInputStream certificateInput = null;
        try {
            certificateInput = new FileInputStream(certificate);
            cert = (X509Certificate) CertificateFactory.getInstance("X509").generateCertificate(certificateInput);
        } catch (Exception e) {
            throw new CertificateEncodingException(e);
        } finally {
            if (certificateInput != null) {
                try {
                    certificateInput.close();
                } catch (IOException e) {
                    if (logger.isWarnEnabled()) {
                        logger.warn("Failed to close a file: " + certificate, e);
                    }
                }
            }
        }
    }

    // getPrefixedExtensionID returns an Object Identifier
    // that can be used in x509 Certificates.
    public static int[] getPrefixedExtensionID(int[] suffix) {

        return Ints.concat(extensionPrefix, suffix);
    }

    static String[] generate(PrivKey privKey, String fqdn, KeyPair keypair,
                             SecureRandom random, Date notBefore, Date notAfter,
                             String algorithm) throws Exception {
        PrivateKey key = keypair.getPrivate();

        BigInteger bigInteger = new BigInteger(64, random);
        // Prepare the information required for generating an X.509 certificate.
        X500Name owner = new X500Name("CN=" + fqdn);


        X509v3CertificateBuilder builder = new JcaX509v3CertificateBuilder(
                owner, bigInteger, notBefore, notAfter, owner, keypair.getPublic());

        PubKey pubKey = privKey.publicKey();
        byte[] keyBytes = Crypto.PublicKey.newBuilder().setType(pubKey.getKeyType())
                .setData(ByteString.copyFrom(pubKey.raw())).build().toByteArray();


        SubjectPublicKeyInfo subjectPublicKeyInfo = SubjectPublicKeyInfo.
                getInstance(keypair.getPublic().getEncoded());
        byte[] signature = privKey.sign(Bytes.concat(
                certificatePrefix.getBytes(), subjectPublicKeyInfo.getEncoded()));


        SignedKey signedKey = new SignedKey(keyBytes, signature);

        ASN1ObjectIdentifier indent = new ASN1ObjectIdentifier(getLiteExtension());
        builder.addExtension(indent, false, signedKey);


        ContentSigner signer = new JcaContentSignerBuilder(
                algorithm.equalsIgnoreCase("EC") ? "SHA256withECDSA" :
                        "SHA256WithRSAEncryption").build(key);
        X509CertificateHolder certHolder = builder.build(signer);
        X509Certificate cert = new JcaX509CertificateConverter().
                setProvider(PROVIDER).getCertificate(certHolder);
        cert.verify(keypair.getPublic());

        return newSelfSignedCertificate(fqdn, key, cert);
    }

    public static String getLiteExtension() {
        return LiteHostCertificate.integersToString(LiteHostCertificate.extensionID);
    }

    public static String integersToString(int[] values) {
        try {
            String s = "";
            for (int i = 0; i < values.length; ++i) {
                if (i > 0) {
                    s = s.concat(".");
                }
                s = s.concat(String.valueOf(values[i]));
            }

            return s;
        } catch (Throwable throwable) {
            throw new RuntimeException(throwable);
        }
    }


    static String[] newSelfSignedCertificate(
            String fqdn, PrivateKey key, X509Certificate cert) throws IOException, CertificateEncodingException {
        // Encode the private key into a file.
        ByteBuf wrappedBuf = Unpooled.wrappedBuffer(key.getEncoded());
        ByteBuf encodedBuf;
        final String keyText;
        try {
            encodedBuf = Base64.encode(wrappedBuf, true);
            try {
                keyText = "-----BEGIN PRIVATE KEY-----\n" +
                        encodedBuf.toString(CharsetUtil.US_ASCII) +
                        "\n-----END PRIVATE KEY-----\n";
            } finally {
                encodedBuf.release();
            }
        } finally {
            wrappedBuf.release();
        }

        File keyFile = PlatformDependent.createTempFile("keyutil_" + fqdn + '_', ".key", null);
        keyFile.deleteOnExit();

        OutputStream keyOut = new FileOutputStream(keyFile);
        try {
            keyOut.write(keyText.getBytes(CharsetUtil.US_ASCII));
            keyOut.close();
            keyOut = null;
        } finally {
            if (keyOut != null) {
                safeClose(keyFile, keyOut);
                safeDelete(keyFile);
            }
        }

        wrappedBuf = Unpooled.wrappedBuffer(cert.getEncoded());
        final String certText;
        try {
            encodedBuf = Base64.encode(wrappedBuf, true);
            try {
                // Encode the certificate into a CRT file.
                certText = "-----BEGIN CERTIFICATE-----\n" +
                        encodedBuf.toString(CharsetUtil.US_ASCII) +
                        "\n-----END CERTIFICATE-----\n";
            } finally {
                encodedBuf.release();
            }
        } finally {
            wrappedBuf.release();
        }

        File certFile = PlatformDependent.createTempFile("keyutil_" + fqdn + '_', ".crt", null);
        certFile.deleteOnExit();

        OutputStream certOut = new FileOutputStream(certFile);
        try {
            certOut.write(certText.getBytes(CharsetUtil.US_ASCII));
            certOut.close();
            certOut = null;
        } finally {
            if (certOut != null) {
                safeClose(certFile, certOut);
                safeDelete(certFile);
                safeDelete(keyFile);
            }
        }

        return new String[]{certFile.getPath(), keyFile.getPath()};
    }

    private static void safeDelete(File certFile) {
        if (!certFile.delete()) {
            if (logger.isWarnEnabled()) {
                logger.warn("Failed to delete a file: " + certFile);
            }
        }
    }

    private static void safeClose(File keyFile, OutputStream keyOut) {
        try {
            keyOut.close();
        } catch (IOException e) {
            if (logger.isWarnEnabled()) {
                logger.warn("Failed to close a file: " + keyFile, e);
            }
        }
    }

    public static PubKey extractPublicKey(@NonNull X509Certificate cert) throws IOException {

        byte[] extension = cert.getExtensionValue(LiteHostCertificate.getLiteExtension());
        Objects.requireNonNull(extension);

        ASN1OctetString octs = (ASN1OctetString) ASN1Primitive.fromByteArray(extension);
        ASN1Primitive primitive = ASN1Primitive.fromByteArray(octs.getOctets());
        DLSequence sequence = (DLSequence) DERSequence.getInstance(primitive);
        DEROctetString pubKeyRaw = (DEROctetString) sequence.getObjectAt(0);

        PubKey pubKey = unmarshalPublicKey(pubKeyRaw.getOctets());
        Objects.requireNonNull(pubKey);

        DEROctetString signature = (DEROctetString) sequence.getObjectAt(1);
        byte[] skSignature = signature.getOctets();

        byte[] certKeyPub = cert.getPublicKey().getEncoded();

        byte[] verify = Bytes.concat(LiteHostCertificate.certificatePrefix.getBytes(), certKeyPub);

        boolean result = pubKey.verify(verify, skSignature);

        if (!result) {
            throw new RuntimeException("Verification process failed");
        }
        return pubKey;

    }

    private static PubKey unmarshalPublicKey(byte[] data) throws InvalidProtocolBufferException {

        Crypto.PublicKey pmes = Crypto.PublicKey.parseFrom(data);

        byte[] pubKeyData = pmes.getData().toByteArray();

        switch (pmes.getType()) {
            case RSA:
                return Rsa.unmarshalRsaPublicKey(pubKeyData);
            case ECDSA:
                return Ecdsa.unmarshalEcdsaPublicKey(pubKeyData);
            case Secp256k1:
                return Secp256k1.unmarshalSecp256k1PublicKey(pubKeyData);
            case Ed25519:
                return Ed25519.unmarshalEd25519PublicKey(pubKeyData);
            default:
                throw new RuntimeException("BadKeyTypeException");
        }
    }

    /**
     * Returns the generated X.509 certificate file in PEM format.
     */
    public File certificate() {
        return certificate;
    }

    /**
     * Returns the generated RSA private key file in PEM format.
     */
    public File privateKey() {
        return privateKey;
    }

    /**
     * Returns the generated X.509 certificate.
     */
    public X509Certificate cert() {
        return cert;
    }

    /**
     * Returns the generated RSA private key.
     */
    public PrivateKey key() {
        return key;
    }

    /**
     * Deletes the generated X.509 certificate file and RSA private key file.
     */
    public void delete() {
        safeDelete(certificate);
        safeDelete(privateKey);
    }

    public static class SignedKey extends ASN1Object {
        private final ASN1OctetString PubKey;
        private final ASN1OctetString Signature;

        public SignedKey(@NonNull byte[] pubKey, @NonNull byte[] signature) {
            PubKey = new DEROctetString(pubKey);
            Signature = new DEROctetString(signature);
        }

        @Override
        public ASN1Primitive toASN1Primitive() {
            ASN1Encodable[] v = new ASN1Encodable[]{this.PubKey, this.Signature};
            return new DERSequence(v);
        }

    }

    /**
     * Insecure {@link SecureRandom} which relies on {@link PlatformDependent#threadLocalRandom()} for random number
     * generation.
     */
    public static final class ThreadLocalInsecureRandom extends SecureRandom {

        private static final long serialVersionUID = -8209473337192526191L;

        private static final SecureRandom INSTANCE = new ThreadLocalInsecureRandom();

        private ThreadLocalInsecureRandom() {
        }

        public static SecureRandom current() {
            return INSTANCE;
        }

        private static Random random() {
            return PlatformDependent.threadLocalRandom();
        }

        @Override
        public String getAlgorithm() {
            return "insecure";
        }

        @Override
        public void setSeed(byte[] seed) {
        }

        @Override
        public void setSeed(long seed) {
        }

        @Override
        public void nextBytes(byte[] bytes) {
            random().nextBytes(bytes);
        }

        @Override
        public byte[] generateSeed(int numBytes) {
            byte[] seed = new byte[numBytes];
            random().nextBytes(seed);
            return seed;
        }

        @Override
        public int nextInt() {
            return random().nextInt();
        }

        @Override
        public int nextInt(int n) {
            return random().nextInt(n);
        }

        @Override
        public boolean nextBoolean() {
            return random().nextBoolean();
        }

        @Override
        public long nextLong() {
            return random().nextLong();
        }

        @Override
        public float nextFloat() {
            return random().nextFloat();
        }

        @Override
        public double nextDouble() {
            return random().nextDouble();
        }

        @Override
        public double nextGaussian() {
            return random().nextGaussian();
        }
    }
}

